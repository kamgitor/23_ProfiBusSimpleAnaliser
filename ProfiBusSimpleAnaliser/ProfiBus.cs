using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Windows.Controls;

enum RX_RET_STATE
{
	FRAME_NOTHING,
	FRAME_OK,
	CRC_ERROR,
	FRAMING_ERROR,		// przyszedl sop a czekalem na eopa
	SIZE_ERROR
};

delegate void delegate_FrameOk(Queue<byte> rx_data);
delegate void delegate_FrameErr(RX_RET_STATE ret);


namespace ProfiBusSimpleAnaliser
{
	class ProfiBus : SerialPortGeneric
	{
		// private delegate_FrameOk EventFrameOk = null;

		public event delegate_FrameOk ProfiFrameOk;
		public event delegate_FrameErr ProfiFrameErr;

		const byte MAG_SOP = 0x68;
		const byte MAG_EOP = 0x16;
		const byte MAG_DLE = 0x80;
		const byte MAG_RX_SIZE = 250;		// maksymalny rozmiar ramki odbiorczej

		private byte crc_l;
		private byte crc_h;

		// private byte rx_byte_cnt = 0;
		private bool rx_frame = false;		// leci ramka
		private bool dles = false;

		private byte[] debug_buffer = new byte[MAG_RX_SIZE];
		UInt16 debug_buffer_cnt = 0;



		// ***************************************************************************
		// Konstruktor podobno nie jest dziedziczony - taka konstrukcja zeby byl dziwdziczony
		public ProfiBus(ComboBox combo) : base(combo)
		{

		}	// ProfiBus


		// ***************************************************************************
		void ResetDebugBuffer()
		{
			for (UInt16 i = 0; i < debug_buffer.Length; i++)
				debug_buffer[i] = 0;

			debug_buffer_cnt = 0;

		}	// ResetDebugBuffer


		// ***************************************************************************
		void AddToDebugBuffer(byte data)
		{
			debug_buffer[debug_buffer_cnt++] = data;
		
		}	// AddToDebugBuffer


		// ***************************************************************************
		// NU Analizowanie ramki wysylanej, w generic - przezroczyste
		override protected byte[] AnaliseTxFrame(byte[] buf)									// override przyslania funkcje virtual
		{
			// Narazie przezroczyste

			return buf;

		}	// AnaliseTxFrame


		// ***************************************************************************
		// Wewnetrzny Event odbioru Rx
		override protected void rx_handler_funct(object sender, System.IO.Ports.SerialDataReceivedEventArgs e)		// override przyslania funkcje virtual
		{
			int rx_size = serial.BytesToRead;
			byte[] buffer = new byte[rx_size];

			int iReaded = serial.Read(buffer, 0, rx_size);

			for (int i = 0; i < rx_size; i++)
			{
				RxByteByByleAnalise(buffer[i]);
				// rx_buffer.Enqueue(buffer[i]);
			}

			// rx_funct(buffer, rx_size);

		}	// rx_handler_funct


		// ***************************************************************************
		/// <summary>
		/// 
		/// </summary>
		/// <param name="data"></param>
		/// @return 0 - nic, 1 - frame ok, -1 - crc error,
		private RX_RET_STATE RxByteByByleAnalise(byte data)
		{

			if (data == MAG_SOP)
			{
				if (rx_frame)
				{
					if (ProfiFrameErr != null)
						ProfiFrameErr(RX_RET_STATE.FRAMING_ERROR);
				}

				ResetDebugBuffer();

				// rx_buffer = new Queue<byte>();
				rx_frame = true;
				dles = false;
				rx_buffer.Clear();
				// rx_byte_cnt = 0;
				ResetCrc();
			}
			else
			{
				if (rx_frame)		// odbiera ramke
				{
					AddToDebugBuffer(data);

					switch (data)
					{
					case MAG_DLE:				//odebrany DLE - escapowac nastepny
						dles = true;
						break;
					case MAG_EOP:				//EOP - porownanie crc i zakonczenie odbioru
						rx_frame = false;

						if ((crc_l == 0) && (crc_h == 0))
						{
							if (ProfiFrameOk != null)
								ProfiFrameOk(rx_buffer);		// Zgloszenie eventu

							return RX_RET_STATE.FRAME_OK;
						}
						else
						{
							if (ProfiFrameErr != null)
								ProfiFrameErr(RX_RET_STATE.CRC_ERROR);

							return RX_RET_STATE.CRC_ERROR;
						}
						
						// break;

					default:						// inny odebrany znak
						if (dles)
						{							// byl escapowany - odescapowac
							data = (byte)~data;
							dles = false;
						}

						rx_buffer.Enqueue(data);
						AddByteCrc(data);

						if (rx_buffer.Count >= MAG_RX_SIZE)		// za dluga ramka
						{
							rx_frame = false;

							if (ProfiFrameErr != null)
								ProfiFrameErr(RX_RET_STATE.SIZE_ERROR);

							return RX_RET_STATE.SIZE_ERROR;
						}
						break;

					}	// switch znak
				}

			}	// nie sop

			return RX_RET_STATE.FRAME_NOTHING;


		}	// RxByteByByleAnalise


		// ***************************************************************************
		void ResetCrc()
		{
			crc_l = 0xFF;
			crc_h = 0xFF;

		}	// ResetCrc


		// ***************************************************************************
		void AddByteCrc(byte data)
		{
			byte crc_idx;

			// tab crc calculating
			crc_idx = (byte)(crc_l ^ data);
			// czesc mlodsza jest skladana z poprzedniej starszej i LO_CRC_BYTES
			crc_l = (byte)(LO_CRC_BYTES[crc_idx] ^ crc_h);
			// czesc starsza jest tylko z HI_CRC_BYTES
			crc_h = HI_CRC_BYTES[crc_idx];

		}	// AddByteCrc




		byte[] LO_CRC_BYTES =
	{0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,
	0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,
	0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,
	0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,
	0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
	0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
	0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,
	0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
	0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
	0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
	0x00,0xC1,0x81,0x40};

		byte[] HI_CRC_BYTES =
	{0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,
	0xC4,0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,
	0xC9,0x09,0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,
	0xDF,0x1F,0xDD,0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,
	0xD2,0x12,0x13,0xD3,0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,
	0xF2,0x32,0x36,0xF6,0xF7,0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,
	0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,
	0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,
	0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,0x22,0xE2,0xE3,0x23,0xE1,0x21,
	0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,0x62,0x66,0xA6,0xA7,0x67,
	0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,0x6E,0xAE,0xAA,0x6A,
	0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB,0x7B,0x7A,0xBA,
	0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,0x77,0xB7,
	0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91,0x51,
	0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
	0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,
	0x88,0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,
	0x4C,0x8C,0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,
	0x41,0x81,0x80,0x40};


	}
}
